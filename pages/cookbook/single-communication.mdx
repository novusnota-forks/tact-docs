# Single-contract Communication

import { Callout } from 'nextra/components'

This page lists examples of communication of a single deployed contract with other contracts on blockchain.

For examples of communication between multiple deployed contracts see: [Multi-contract communication](/cookbook/multi-communication).

## How to make a basic reply

```tact
receive() {
    self.reply("Hello, World!".asComment());
}
```

<Callout>

  **Useful links:**\
  [`self.reply(){:tact}` in Core library](/ref/core-base#self-reply)\
  [`String.asComment(){:tact}` in Core library](/ref/core-strings#stringascomment)

</Callout>

## How to send a regular message

### With a default mode and no optional flags [#regular-default]

```tact
send(SendParameters{
    bounce: true, // default
    to: someDestinationAddress,
    value: ton("0.1"), // attached amount of Tons to send
    body: "Hello from Tact!".asComment(), // comment as a body (optional)
});
```

### With `SendPayGasSeparately` [#regular-paygasseparately]

Paying [forward fees](https://docs.ton.org/develop/smart-contracts/guidelines/processing) separately from the message value.

```tact
send(SendParameters{
    // bounce: true by default
    to: groundControl,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendPayGasSeparately,
});
```

### With `SendIgnoreErrors` [#regular-sendignoreerrors]

Ignoring any errors arising while processing this message during the [action phase](https://docs.ton.org/learn/tvm-instructions/tvm-overview#transactions-and-phases).

```tact
send(SendParameters{
    // bounce: true by default
    to: majorTom,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendIgnoreErrors,
});
```

### With `SendBounceIfActionFail` [#regular-sendbounceifactionfail]

Bouncing the transaction in case of any errors during action phase. Has no effect if flag [`SendIgnoreErrors{:tact}`](#regular-sendignoreerrors) is used.

```tact
send(SendParameters{
    // bounce: true by default
    to: deepThought,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendBounceIfActionFail,
});
```

### With `SendDestroyIfZero` [#regular-senddestroyifzero]

Destroing current contract if its resulting balance is zero (often used with mode [`SendRemainingBalance{:tact}`](#remainingbalance-default)).

```tact
send(SendParameters{
    // bounce: true by default
    to: zaphodBeeblebrox,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendDestroyIfZero,
});
```

## How to send a message carrying all the remaining value

### Without optional flags, `SendRemainingValue` [#remainingvalue-default]

Carrying all the remaining value of the inbound message (the one we've just received) in addition to the value initially indicated in the message (the one we're about to send).

```tact
send(SendParameters{
    // bounce: true by default
    to: jamesBond,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendRemainingValue,
});
```

### With `SendPayGasSeparately` [#remainingvalue-paygasseparately]

```tact
send(SendParameters{
    // bounce: true by default
    to: groundControl,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendRemainingValue | SendPayGasSeparately,
});
```

### With `SendIgnoreErrors` [#remainingvalue-sendignoreerrors]

```tact
send(SendParameters{
    // bounce: true by default
    to: majorTom,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendRemainingValue | SendIgnoreErrors,
});
```

### With `SendBounceIfActionFail` [#remainingvalue-sendbounceifactionfail]

```tact
send(SendParameters{
    // bounce: true by default
    to: deepThought,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendRemainingValue | SendBounceIfActionFail,
});
```

### With `SendDestroyIfZero` [#remainingvalue-senddestroyifzero]

```tact
send(SendParameters{
    // bounce: true by default
    to: zaphodBeeblebrox,
    value: ton("0.1"), // attached amount of Tons to send
    mode: SendRemainingValue | SendDestroyIfZero,
});
```

## How to send a message carrying all the remaining balance

### Without optional flags, `SendRemainingBalance` [#remainingbalance-default]

TODO

and x4 from prev thing

"X"
"Like X, but also"
"Like X, but also"
"Like X, but also"
"Like X, but also"

TODO: re-do other things below

## How to send a message with the entire balance

If we need to send the whole balance of the smart contract, then we should use the `SendRemainingBalance{:tact}` send mode. Alternatively, we can use `mode: 128{:tact}`, which has the same meaning.

```tact
send(SendParameters{
    // bounce = true by default
    to: sender(), // send the message back to the original sender
    value: 0,
    mode: SendRemainingBalance, // or mode: 128
    body: "Hello from Tact!".asComment(), // comment (optional)
});
```

## How to send a message with the remaining value

If we want to make a reply to the same sender, we can use the mode `SendRemainingValue{:tact}` (i.e. `mode: 64{:tact}`), which carries all the remaining value of the inbound message in addition to the value initially indicated in the new message.

```tact
send(SendParameters{
    // bounce = true by default
    to: sender(), // send the message back to the original sender
    value: 0,
    mode: SendRemainingValue,
    body: "Hello from Tact!".asComment(), // comment (optional)
});
```

It's often useful to add the `SendIgnoreErrors{:tact}` flag too, in order to ignore any errors arising while processing this message during the action phaseL

```tact
send(SendParameters{
    // bounce = true by default
    to: sender(), // send the message back to the original sender
    value: 0,
    mode: SendRemainingValue | SendIgnoreErrors, // prefer using | over + for the mode
    body: "Hello from Tact!".asComment(), // comment (optional)
});
```

The latter example is identical to using a [`.reply(){:tact}` function](#how-to-make-a-basic-reply).

## How to send a message with a long text comment

If we need to send a message with a lengthy text comment, we should create a [`String{:tact}`](/book/types#primitive-types) that consists of more than $127$ characters. To do this, we can utilize the [`StringBuilder{:tact}`](/book/types#primitive-types) primitive type and its methods called `beginComment(){:tact}` and `append(){:tact}`. Prior to sending, we should convert this string into a cell using the `toCell(){:tact}` method.

```tact
let comment: StringBuilder = beginComment();
let longString = "..."; // Some string with more than 127 characters.
comment.append(longString);

send(SendParameters{
    // bounce = true by default
    to: sender(),
    value: 0,
    mode: SendIgnoreErrors,
    body: comment.toCell(),
});
```

<Callout>

  **Useful links:**\
  ["Sending messages" in the Book](/book/send#send-message)\
  ["Message `mode`" in the Book](/book/message-mode)\
  [`StringBuilder{:tact}` in the Book](/book/types#primitive-types)\
  [`Cell{:tact}` in Core library](/ref/core-cells)

</Callout>

<Callout type="info" emoji="ðŸ¤”">

  Didn't find your favorite example of a single-contract communication? Have cool implementations in mind? [Contributions are welcome!](https://github.com/tact-lang/tact-docs/issues)

</Callout>
